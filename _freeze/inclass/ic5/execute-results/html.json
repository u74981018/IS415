{
  "hash": "0373cab82ecad30f082c7934730896c0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class 5\"\nauthor: \"Lucas Vial\"\ndate: \"Sep 16 2024\"\ndate-modified: \"Date\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n  warning: false\n---\n\n\nArrived only 5 minutes late!\n\n## Lectured Slide Notes \n\nSpatial Weights (wij), How we define spatial neighbourhoods. (are these two things neighbours, wij is how we decide!)\n\n-   Adjacency criterion: Is it right next to each other? Binary Output\n\n-   Distance criterion: If its within a set a parameter of distance (use your little dots) - if location j is within distance d from i\n\n-   You can also give them their own weights; not a pass fail its close to the one\n\nContiguity Neighbors\n\n-   Rooks, Bishops, Queen\n\n-   Second-Order (up to X-th Order) Contiguity\n\n    -   Degrees of Seperation\n\n    -   If your second, you have one between\n\n    -   first is basic or right next to you\n\n-   weights matrix - its a matrix ðŸ¤ \n\n    -   Can be binary or Distance based (0 for self)\n\nRow Standardisation (or column)\n\n-   This is just to see how many neighbours each thing has\n\nthat one graph that uses row standardisation and lagged variables to show how the east is richer than the west. (the sum one includes itself)\n\n## In-Class  \n\nInstall the GWmodel tool in the dropdown\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, knitr, GWmodel)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# import shapefile and parse it to a sf polygon feature object\nhunan <- st_read(dsn = \"data/data_5/data/geospatial\", \n                 layer = \"Hunan\")\n# you should be finding out the projections and doing it accordingly, we didn't because lazy\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# import csv and parse it into tibble df \nhunan2012 <- read_csv(\"data/data_5/data/aspatial/Hunan_2012.csv\")\n# Join Hunan and Hunan_2012 csv \nhunan <- left_join(hunan,hunan2012) #%>%\n#  select(1:4, 7, 15)\n # select(1:3, 7, 15, 16, 31, 32)\n# this is called data tidying, its so we dont have useless cols\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(hunan, \"data/data_5/data/hunan.rds\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nRDS are used to save the data thats been wrangled, it speeds the process up for subsequent use and uses less memory.\n\nConvert to Spatial Polygon Data Frame\n\n-   the thing we are using doesnt like sf ðŸ˜­\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_sp <- hunan_sf %>%\n  as_Spatial()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_AIC <- bw.gwr(GDPPC ~ 1,\n                 data = hunan_sp,\n                 approach = \"AIC\",\n                 adaptive = TRUE,\n                 kernel = \"bisquare\",\n                 longlat = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAdaptive bandwidth (number of nearest neighbours): 62 AICc value: 1923.156 \nAdaptive bandwidth (number of nearest neighbours): 46 AICc value: 1920.469 \nAdaptive bandwidth (number of nearest neighbours): 36 AICc value: 1917.324 \nAdaptive bandwidth (number of nearest neighbours): 29 AICc value: 1916.661 \nAdaptive bandwidth (number of nearest neighbours): 26 AICc value: 1914.897 \nAdaptive bandwidth (number of nearest neighbours): 22 AICc value: 1914.045 \nAdaptive bandwidth (number of nearest neighbours): 22 AICc value: 1914.045 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_CV <- bw.gwr(GDPPC ~ 1,\n                 data = hunan_sp,\n                 approach = \"CV\",\n                 adaptive = TRUE,\n                 kernel = \"bisquare\",\n                 longlat = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAdaptive bandwidth: 62 CV score: 15515442343 \nAdaptive bandwidth: 46 CV score: 14937956887 \nAdaptive bandwidth: 36 CV score: 14408561608 \nAdaptive bandwidth: 29 CV score: 14198527496 \nAdaptive bandwidth: 26 CV score: 13898800611 \nAdaptive bandwidth: 22 CV score: 13662299974 \nAdaptive bandwidth: 22 CV score: 13662299974 \n```\n\n\n:::\n:::\n\n\nYou can used fixed bandwidth (change adaptive to false)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwstat <- gwss(data = hunan_sp,\n               vars = \"GDPPC\",\n               bw = bw_AIC,\n               kernel = \"bisquare\",\n               adaptive = TRUE,\n               longlat = T)\n```\n:::\n\n\nPut the good stuff in a dataframe\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwstat_df <- as.data.frame(gwstat$SDF)\n```\n:::\n\n\nAdd it to hunan_sf, then you have it in your main data! - will be helpful for graph\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_gstat <- cbind(hunan_sf, gwstat_df)\n# this is appending \n```\n:::\n\n\nCode Displaying it\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(hunan_gstat) +\n  tm_fill(\"GDPPC_LM\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Distribution of geographically weighted mean\", \n            main.title.position = \"center\", \n            main.title.size = 0.5, \n            legend.text.size = 1.2, \n            frame = TRUE)\n```\n\n::: {.cell-output-display}\n![](ic5_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "ic5_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}